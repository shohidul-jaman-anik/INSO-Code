import Anthropic from '@anthropic-ai/sdk';
import { InMemoryChatMessageHistory } from '@langchain/core/chat_history';
import { AIMessage, HumanMessage } from '@langchain/core/messages';
import httpStatus from 'http-status';
import { BufferMemory } from 'langchain/memory';
import mongoose from 'mongoose';
import ApiError from '../../../errors/ApiError.js';
import { logger } from '../../../shared/logger.js';
import UserModel from '../auth/auth.model.js';
import Llama from './dyad.model.js';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

// In-memory session memory
const sessionMemoryStore = {};

const claudeResponseService = async (prompt, userId, sessionId) => {
  let memory = sessionMemoryStore[sessionId];
  if (!memory) {
    memory = new BufferMemory({
      returnMessages: true,
      memoryKey: 'history',
      chatHistory: new InMemoryChatMessageHistory(),
    });
    sessionMemoryStore[sessionId] = memory;
  }

  try {
    await memory.chatHistory.addMessage(new HumanMessage(prompt));

    const previousMessages = await memory.chatHistory.getMessages();
    const messages = previousMessages.map(msg => ({
      role: msg._getType() === 'human' ? 'user' : 'assistant',
      content: msg.content,
    }));

    const startTime = Date.now();

    // Claude Sonnet 4.5 API call
    const completion = await anthropic.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 1500,
      messages: [...messages, { role: 'user', content: prompt }],
    });

    const endTime = Date.now();
    const totalTime = endTime - startTime;

    const reply =
      completion.content?.[0]?.text || 'No response generated by Claude.';

    // Payment tracking
    // try {
    //   const paymentResult =
    //     await paymentController.incrementPromptsUsed(userId);
    //   if (!paymentResult.success) {
    //     throw new ApiError(httpStatus.BAD_REQUEST, paymentResult.message);
    //   }
    // } catch (error) {
    //   logger.error('Error in incrementPromptsUsed:', error);
    //   throw new ApiError(
    //     httpStatus.INTERNAL_SERVER_ERROR,
    //     error.message || 'An error occurred while updating prompt usage.',
    //   );
    // }

    await memory.chatHistory.addMessage(new AIMessage(reply));

    const responseData = {
      prompt,
      model: 'claude-sonnet-4-5-20250929',
      reply,
      total_time: totalTime,
    };

    let claudeSession = await Llama.findOne({ user: userId, sessionId });

    if (claudeSession) {
      claudeSession.responses.push(responseData);
      await claudeSession.save();
    } else {
      claudeSession = await Llama.create({
        user: userId,
        sessionId: sessionId,
        responses: [responseData],
      });
      await UserModel.findByIdAndUpdate(userId, {
        $push: { llamaAiSessions: claudeSession._id },
      });
    }

    const payload = { sessionId, prompt, reply };
    console.log('Claude Response Payload:', payload);
    return payload;
  } catch (error) {
    logger.error('Error in claudeResponseService:', error);
    throw new ApiError(
      httpStatus.INTERNAL_SERVER_ERROR,
      'Claude service failed.',
    );
  }
};

const getAiResponsesByUserIdService = async userId => {
  const sessionData = await UserModel.findOne({
    _id: userId,
  })
    .select('email profile')
    .populate({
      path: 'llamaAiSessions',
    });
  // logger.info(sessionData, 'sessionData');
  if (!sessionData) {
    return {
      statusCode: httpStatus.NOT_FOUND,
      success: false,
      message: 'Session not found',
      reply: sessionData,
    };
  }
  return sessionData;
};

const getAiResponsesBySession = async id => {
  const sessionData = await Llama.findOne({
    sessionId: id,
  });
  // logger.info(sessionData, 'sessionData');

  if (!sessionData) {
    return {
      statusCode: httpStatus.NOT_FOUND,
      success: false,
      message: 'Session not found',
      response: sessionData,
    };
  }
  return sessionData;
};

const deleteOneLlamaAiSession = async objectId => {
  const userData = await Llama.findOne({
    _id: objectId,
  });
  if (!userData) {
    throw new Error('LlamaAiSession not found');
  }
  const deleteResult = await Llama.deleteOne({
    _id: objectId,
  });

  // Check if the LlamaAiSession was successfully deleted
  if (deleteResult.deletedCount === 1) {
    // Remove the LlamaAiSession reference from the user model
    const userUpdateResult = await UserModel.updateOne(
      { _id: userData.user },
      { $pull: { llamaAiSessions: objectId } },
    );

    logger.info(userUpdateResult, 'userUpdateResult userUpdateResult');

    // Check if the user model was successfully updated
    if (userUpdateResult.modifiedCount === 1) {
      return {
        success: true,
        message: 'LlamaAiSession and user reference deleted successfully',
      };
    } else {
      throw new Error('Failed to update the user model');
    }
  } else {
    throw new Error('Failed to delete the LlamaAiSession');
  }
};

const deleteAllAiSessionsService = async userId => {
  const session = await mongoose.startSession();

  try {
    await session.startTransaction();

    // Fetch user data to get the LlamaAiSession array
    const user = await UserModel.findById(userId).session(session);
    if (
      !user ||
      !user.llamaAiSessions ||
      !Array.isArray(user.llamaAiSessions)
    ) {
      throw new Error('User or LlamaAiSession data not found');
    }

    const aiSessionIds = user.llamaAiSessions.map(id => id.toString());
    // logger.info('AI Session IDs to delete:', aiSessionIds);

    // Delete the AI sessions
    const deleteResults = await Promise.all(
      aiSessionIds.map(id => Llama.deleteOne({ _id: id }).session(session)),
    );

    // logger.info('Delete Results:', deleteResults);

    // Check if all AI sessions were successfully deleted
    const allDeleted = deleteResults.every(result => result.deletedCount === 1);
    if (!allDeleted) {
      throw new Error('Failed to delete one or more AI sessions');
    }

    // Remove the AI session references from the user model
    const userUpdateResult = await UserModel.updateOne(
      { _id: userId },
      { $pull: { llamaAiSessions: { $in: aiSessionIds } } },
    ).session(session);

    // logger.info('User update result:', userUpdateResult);

    if (userUpdateResult.acknowledged && userUpdateResult.modifiedCount > 0) {
      await session.commitTransaction();
      session.endSession();
      return {
        statusCode: 200,
        success: true,
        message: 'AI sessions and user references deleted successfully',
      };
    } else {
      throw new Error('Failed to update the user model');
    }
  } catch (error) {
    await session.abortTransaction();
    session.endSession();
    console.error('An error occurred:', error);
    return {
      success: false,
      message: 'An internal server error occurred',
      error: error.message,
    };
  }
};
export const ClaudeServices = {
  claudeResponseService,
  getAiResponsesByUserIdService,
  getAiResponsesBySession,
  deleteOneLlamaAiSession,
  deleteAllAiSessionsService,
};
